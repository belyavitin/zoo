Дневник разработки проекта зоопарк для DATASAKURA.

 "Все нужное просто, все сложное не нужно" — Михаил Тимофеевич Калашников
 
CUPID:
composable - plays well with others
unix - does one thing well
predictable - does what you expect
idiomatic - feels natural
domain-based - models the problem domain in language and structure

13:30 17 июня 2025 года.
 
Каков мой личный вызов здесь? Написать что-то за день так чтобы было интересно смотреть, чтобы было интересно читать и чтобы не переусложнить.
  
Для начала попробую переварить то тз, которое я получил, потому что ориентироваться будет проще.

Тестовое задание заключается в том, чтобы создать 3д зоопарк, в котором можно увидеть различных животных.
Почему-то это называется игрой, хотя не указан ни один вид взаимодействия игрока с миром игры. Ну ок.
Камера должна быть с видом сверху, на приложенном скриншоте она в перспективном режиме.
Для элементов игры достаточно использовать стандартные примитивы юнити - кубы, сферы и проч. 

Вот всё, что я знаю про геймплей:
Раз в 1-2 секунды на поле появляется животное и начинает двигаться случайным образом. 
У него и у игрового мира есть физика, по которой оно регистриует столкновения с другими животными.
Кроме этого, есть правило изменять направление движения при выходе за пределы видимой зоны так чтобы оставаться в ней.
Описаны два типа животных - хищники и корм.
Корм при столкновении с другим кормом просто разлетается в стороны по физике. Если сталкивается с хищником то умирает и исчезает с экрана.
Хищник - если сталкивается с другим животным, то съедает его. Если хищник сталкивается с другим хищником, то один из них съедает другого, кто - можно определить самым удобным образом.
Каждый раз как жищник съедает животное, под хищником должна возникнуть надпись "Tasty!"

Жаба - это корм. Передвигается прыжками. Каждые Х секунд прыгает на фиксированное расстояние.
Змея - это хищник. Передвигается плавно, на фиксированное расстояние за секунду.

Не указано, но на скрине подразумевается, что есть препятствия для передвижения. Предположим что они статичные и не влияют на поведение животных.

Кроме этого, в верхнем правом углу должен быть счётчик мёртвых хищников и мёртвого корма, сделанный на uGUI.

Основной целью этого теста является проверить умение писать архитектуру для животных, а именно, ясный, лёгкий для расширения и лёгкий для понимания код. Рассчитывать надо на тыщу разных животных в будущем - птиц, пауков, рыб, крабов и так далее. Можно также продемонстрировать понимание DI и других фреймворков, а также паттернов.

Теперь моё мнение по поводу этого задания.

1) не понятно, почему это называется "игра", если нет никаких способов взаимодействия с игрой. Задам вопрос в чате хх, чтобы узнать, предполагается ли какая-либо инициатива в этом направлении или надо просто закодить симулятор. Пока буду ожидать ответ - буду делать симулятор, потому что интерактивность можно дописать и потом. Но что-то мне подсказывает что лучше заранее её заложить.

2) не понятно, что должно быть с UI - нет никаких окон, стейтов игры и прочего, только счётчик и надпись Tasty. Предположу что это для упрощения задачи и не буду городить стандартную структуру с переходами между сценами игр, меню и проч, и префабами окон и прочего интерфейса, которая есть в любой большой игре. Но заложу возможность расширения надписей.

3) По имеющемуся описанию (жабы, змеи, потом птицы, пауки, рыбы, крабы) сложно предположить, на какие дополнительные компоненты понадобится разбивать поведение, поэтому проектировать буду от функционала - передвижение и поедание, с прогнозом что потом появятся какие-то параметры и органы чувств у каждого животного и поведение на их основе.

4) не понятно, какую архитектуру выбирать - с одной стороны, компонентная система позволит легко и просто получать данные от физики, с другой - хочется создать стандартную ООП модель животного с поведением или даже использовать примитивный ECS для ускорения, НО! в тз не написано "быстро", в тз написано "ясно и расширяемо", а про программиста, который будет этот код читать, я не знаю ничего кроме того что он знает юнити :), поэтому пойду на компромисс и сделаю самую стандартную UnityWay⁻архитектуру. 
Сделаю машину состояний для животного (пока с двумя состояниями но это же у нас зоопарк, вдруг понадобится чтобы животное спало или там пугалось, или вдруг появятся падальщики, которые питаются строго мертвечиной) с эффекторами через действия. Тут надо правильно выбрать названия, чтобы было недвусмысленно понятно что это такое. После консультации со словарём для эффекторов выбираю слово Performer, и реализации - PredatorEatPerformer, ToadJumpPerformer, SnakeMovePerformer. 

С поеданием всё понятно вроде - при столкновении посмотреть, с кем, если можно - то съесть, результат поедания - смерть корма, надпись Tasty под хищником. Здесь мне кажется будет достаточно проверять на наличие компонента ZooAnimal.

С появлением тоже вроде всё понятно - можно создать зону появления и указать кто в ней появляется.

С передвижением интереснее, потому что надо учесть динамически меняющийся размер экрана, причём в обеих классах. Конечно, не стоит передавать в животное камеру напрямую - очевидное решение сделать класс клетки для животных ZooEnclosure , с которым и будут консультироваться животные при движении.

14:30 

Дописан дневник разработки, закончена базовая настройка проекта и насоздано тестовых объектов. Добавлены пакеты Visual Studio Editor и Unity UI. Займусь прописыванием классов, интерфейсов и взаимосвязей.

15:30

Проект настолько элементарный что даже неловко бить его на части, но давайте. Сначала сделаем поле и животных, потом сделаем чтобы они двигались как надо, включая возврат в зону экрана, потом сделаем события Tasty и подсчёт смертей. Отведу предварительно по часу на каждый этап. По сроку от рекрутера пока ответа нет.

16:30-18:00 перерыв на обед :)
18:00-20:30 личные вопросы
20:30 и вот тут возник вопрос как сделать отслеживание параметров. Решил что пока сделаю частные классы которые будут ловить и считать эвенты смерти, заодно туда же и эффект Tasty напишу
00:30 застрял с физикой, потому что развлекал себя тем чтобы сделать прыжки и ползание, хоть это и не требовалось ( пойду спать, завтра закончу

4 июля 2025, 14:00 нашлась возможность продолжить и надеюсь что закончить этот проект

решил попробовать обойтись без Zenject но оставлю комментарии в тех местах где вижу его пользу.
Пишу поедание, счётчики и события.
Для событий решил попробовать использовать что-нибудь новое и простое - UnityMessagingSystem.
В нём понравилась простота, но не понравилось то что это по сути синглтон и нельзя разбить эвенты на несколько систем. Для этого проекта сойдёт, но для серьёзного проекта придётся переписывать, опять же подписки и отписки мне не очень понравились тем что надо копипастить на каждый тип.

18:00
Почти закончил, всё работает, теперь надо привести всё в порядок. Было немного скучно, сделал систему фрустрации, чтобы змеи не втыкались в стены, и чтобы трупы исчезали не сразу.

20:00
финальная чистка кода и саморевью